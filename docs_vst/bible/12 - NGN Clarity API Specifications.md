# NGN Clarity API Specifications
## Complete Integration Guide for Vault, Nexus, Ledger, and Pulse

**Document Version**: 1.0
**Date**: February 11, 2025
**Status**: Active Specification

---

## Overview

This document contains exact API specifications for integrating NGN Clarity with Graylight Creative's G-Fleet services. All endpoints, request/response formats, authentication methods, and error handling are documented here.

---

## Part 1: Vault Integration (HMAC-SHA256)

### Service: Vault
**Purpose**: Secure key management and build-time secret injection
**Base URL**: N/A (GitHub Actions Secrets)
**Authentication**: GitHub Actions environment variables

### HMAC-SHA256 Build-Time Integration

#### How It Works

The Vault HMAC secret is retrieved during the CI/CD build process (GitHub Actions) and compiled directly into the plugin binary as an obfuscated byte array. This happens once during the build, not at runtime.

#### GitHub Actions Secret Setup

**Secret Name**: `GRAYLIGHT_HMAC_SECRET_KEY`

**Secret Format**: 64 hexadecimal characters (32 bytes)

```bash
# Example (DO NOT USE IN PRODUCTION)
GRAYLIGHT_HMAC_SECRET_KEY=a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6
```

#### CMake Build Configuration

During PHASE_0 (Project Setup), the build system reads the secret and injects it:

```cmake
# CMakeLists.txt (during build)

# Read GitHub Actions secret
set(HMAC_SECRET_KEY $ENV{GRAYLIGHT_HMAC_SECRET_KEY})

# Obfuscate and embed in C++ source
configure_file(
    "${CMAKE_SOURCE_DIR}/Source/Licensing/HMAC_Keys.h.in"
    "${CMAKE_BINARY_DIR}/Source/Licensing/HMAC_Keys.h"
)
```

**Source Template** (`Source/Licensing/HMAC_Keys.h.in`):

```cpp
#pragma once

#include <array>

// DO NOT COMMIT THIS FILE - IT CONTAINS SECRETS
// This file is generated by CMake during the build process
// The actual secret is injected from GitHub Actions Secrets

namespace Licensing {
    // Obfuscated HMAC-SHA256 secret key (32 bytes)
    // Generated at build-time from GRAYLIGHT_HMAC_SECRET_KEY
    constexpr std::array<uint8_t, 32> HMAC_SECRET = {
        // @CMAKECONFIG_HMAC_SECRET_OBFUSCATED@
    };

    // De-obfuscation XOR key (changes per build)
    constexpr uint8_t XOR_KEY = @CMAKECONFIG_XOR_KEY@;
}
```

#### De-obfuscation at Runtime

The compiled key is obfuscated using a simple XOR cipher. At runtime, the plugin de-obfuscates it:

```cpp
// Source/Licensing/HMACKeyManager.cpp

#include "HMAC_Keys.h"
#include <openssl/hmac.h>
#include <vector>

class HMACKeyManager {
private:
    std::vector<uint8_t> deobfuscated_key;

public:
    HMACKeyManager() {
        // De-obfuscate the embedded key
        deobfuscated_key.resize(Licensing::HMAC_SECRET.size());
        for (size_t i = 0; i < Licensing::HMAC_SECRET.size(); ++i) {
            deobfuscated_key[i] = Licensing::HMAC_SECRET[i] ^ Licensing::XOR_KEY;
        }
    }

    // Compute HMAC-SHA256 of a message
    std::string computeHMAC(const std::string& message) const {
        unsigned char digest[EVP_MAX_MD_SIZE];
        unsigned int digest_len = 0;

        HMAC(EVP_sha256(),
             deobfuscated_key.data(),
             deobfuscated_key.size(),
             (unsigned char*)message.c_str(),
             message.length(),
             digest,
             &digest_len);

        // Convert to hex string
        std::ostringstream ss;
        for (unsigned i = 0; i < digest_len; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
        }
        return ss.str();
    }

    // Clear key from memory on destruction
    ~HMACKeyManager() {
        OPENSSL_cleanse(deobfuscated_key.data(), deobfuscated_key.size());
    }
};
```

### Online Activation Request Format

When a user enters a license key, the plugin computes an HMAC signature and sends it to the activation endpoint.

#### Request

**Endpoint**: (Backend endpoint, implemented in PHASE_7)
**Method**: `POST`
**Content-Type**: `application/json`

**Headers**:
```
Content-Type: application/json
X-Graylight-Signature: <HMAC-SHA256 signature>
```

**Body**:
```json
{
  "hardware_id": "ABC123-DEF456-GHI789",
  "license_key": "NGN-XXXX-XXXX-XXXX",
  "timestamp": 1707561000,
  "action": "activate"
}
```

**Fields**:
- `hardware_id` (string): Machine fingerprint (see PHASE_2A for generation)
- `license_key` (string): User's license key from purchase email
- `timestamp` (integer): UNIX timestamp (seconds since epoch)
- `action` (string): "activate" or "validate" or "deactivate"

**Signature Calculation**:

```cpp
// 1. Create payload (JSON string, no extra whitespace)
std::string payload = R"({"hardware_id":"ABC123-DEF456-GHI789","license_key":"NGN-XXXX-XXXX-XXXX","timestamp":1707561000,"action":"activate"})";

// 2. Compute HMAC-SHA256
std::string signature = hmac_manager.computeHMAC(payload);

// 3. Send signature in X-Graylight-Signature header
// signature = "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b"
```

#### Response

**Success (200)**:
```json
{
  "status": "activated",
  "license_key": "NGN-XXXX-XXXX-XXXX",
  "email": "user@example.com",
  "expiration_date": "2026-02-11",
  "machine_limit": 2,
  "machines_activated": [
    {
      "hardware_id": "ABC123-DEF456-GHI789",
      "activated_date": "2025-02-11",
      "last_validation": "2025-02-11T14:30:00Z"
    }
  ],
  "signature_verified": true
}
```

**Invalid Signature (401)**:
```json
{
  "error": "invalid_signature",
  "message": "HMAC signature verification failed",
  "timestamp": 1707561000
}
```

**Replay Attack (400)**:
```json
{
  "error": "expired_timestamp",
  "message": "Timestamp is older than 300 seconds (5 minutes)",
  "current_timestamp": 1707561500,
  "request_timestamp": 1707561000
}
```

---

## Part 2: Nexus Integration (Identity & SSO)

### Service: Nexus
**Purpose**: User authentication and identity management
**Base URL**: `https://nexus.graylightcreative.com/api/v1`
**Authentication**: Bearer Token (JWT) for user endpoints; Forge API Key for backend endpoints

### Endpoints

#### 1. User Registration

**Endpoint**: `POST /auth/register`

**Request**:
```json
{
  "email": "user@example.com",
  "password": "secure_password_123",
  "first_name": "John",
  "last_name": "Doe"
}
```

**Response (201)**:
```json
{
  "success": true,
  "user_id": "user_550e8400e29b41d4a716446655440000",
  "email": "user@example.com",
  "jwt_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "jwt_expires_in": 3600,
  "profile": {
    "first_name": "John",
    "last_name": "Doe",
    "avatar_url": null,
    "created_at": "2025-02-11T14:30:00Z"
  }
}
```

**Errors**:
- `409 Conflict`: Email already registered
- `400 Bad Request`: Invalid email format or weak password
- `429 Too Many Requests`: Rate limited (5 registrations per IP per hour)

#### 2. User Login

**Endpoint**: `POST /auth/login`

**Request**:
```json
{
  "email": "user@example.com",
  "password": "secure_password_123"
}
```

**Response (200)**:
```json
{
  "success": true,
  "user_id": "user_550e8400e29b41d4a716446655440000",
  "email": "user@example.com",
  "jwt_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "jwt_expires_in": 3600,
  "profile": {
    "first_name": "John",
    "last_name": "Doe",
    "avatar_url": "https://...",
    "created_at": "2025-02-10T09:15:00Z",
    "last_login": "2025-02-11T14:30:00Z"
  }
}
```

**Errors**:
- `401 Unauthorized`: Invalid email or password
- `429 Too Many Requests`: Rate limited (10 login attempts per 15 minutes)

#### 3. Password Reset Request

**Endpoint**: `POST /auth/password-reset-request`

**Request**:
```json
{
  "email": "user@example.com"
}
```

**Response (200)**:
```json
{
  "success": true,
  "message": "Password reset email sent",
  "email_sent_to": "user@example.com"
}
```

**Note**: Always returns 200 (security: don't reveal if email exists)

#### 4. Password Reset Confirm

**Endpoint**: `POST /auth/password-reset-confirm`

**Request**:
```json
{
  "reset_token": "reset_token_from_email",
  "new_password": "new_secure_password_456"
}
```

**Response (200)**:
```json
{
  "success": true,
  "message": "Password reset successful"
}
```

#### 5. Get Current User Profile

**Endpoint**: `GET /users/profile`

**Headers**:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Response (200)**:
```json
{
  "user_id": "user_550e8400e29b41d4a716446655440000",
  "email": "user@example.com",
  "first_name": "John",
  "last_name": "Doe",
  "avatar_url": "https://...",
  "created_at": "2025-02-10T09:15:00Z",
  "last_login": "2025-02-11T14:30:00Z",
  "email_verified": true,
  "products": ["ngn_2.0", "gosiggy", "myindipro"]
}
```

#### 6. Update User Profile

**Endpoint**: `PATCH /users/profile`

**Headers**:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json
```

**Request**:
```json
{
  "first_name": "Jonathan",
  "last_name": "Doe",
  "avatar_url": "https://custom-avatar-url.com/john.jpg"
}
```

**Response (200)**:
```json
{
  "success": true,
  "user_id": "user_550e8400e29b41d4a716446655440000",
  "profile": {
    "first_name": "Jonathan",
    "last_name": "Doe",
    "avatar_url": "https://custom-avatar-url.com/john.jpg",
    "updated_at": "2025-02-11T14:35:00Z"
  }
}
```

#### 7. Logout

**Endpoint**: `POST /auth/logout`

**Headers**:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Response (200)**:
```json
{
  "success": true,
  "message": "Logged out successfully"
}
```

### Backend-to-Nexus Authentication

The NGN 2.0 backend (PHASE_7) uses a Forge API Key to authorize requests to Nexus:

#### Request with Forge API Key

**Endpoint**: Any backend-to-Nexus call (admin functions)
**Method**: Depends on operation
**Header**:
```
Authorization: Bearer <FORGE_API_KEY>
X-Forge-Service: ngn-2.0
X-Request-ID: <unique-request-id>
```

Example: **Verify User Exists**

**Endpoint**: `GET /users/verify-email/:email`

**Request**:
```
GET /users/verify-email/user@example.com
Authorization: Bearer forge_key_xyz123...
X-Forge-Service: ngn-2.0
X-Request-ID: req_550e8400e29b41d4a716446655440000
```

**Response (200)**:
```json
{
  "exists": true,
  "user_id": "user_550e8400e29b41d4a716446655440000",
  "email_verified": true
}
```

### JWT Structure

**Header**:
```json
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "nexus_key_2025_01"
}
```

**Payload**:
```json
{
  "sub": "user_550e8400e29b41d4a716446655440000",
  "email": "user@example.com",
  "first_name": "John",
  "last_name": "Doe",
  "iat": 1707561000,
  "exp": 1707564600,
  "iss": "https://nexus.graylightcreative.com",
  "aud": ["ngn-2.0", "gosiggy", "myindipro"],
  "scope": "user:read user:write"
}
```

**Signature**: HMAC-SHA256 with Nexus private key

### JWT Validation in NGN 2.0 Backend

```javascript
// Node.js / Express example (PHASE_7)

const jwt = require('jsonwebtoken');
const nexusPublicKey = fs.readFileSync('/etc/graylight/nexus-public-key.pem');

function validateNexusJWT(token) {
  try {
    const decoded = jwt.verify(token, nexusPublicKey, {
      algorithms: ['HS256'],
      issuer: 'https://nexus.graylightcreative.com',
      audience: 'ngn-2.0'
    });
    return { valid: true, user: decoded };
  } catch (error) {
    return { valid: false, error: error.message };
  }
}

// In Express middleware
app.use((req, res, next) => {
  const authHeader = req.headers['authorization'];
  if (!authHeader) {
    return res.status(401).json({ error: 'Missing authorization header' });
  }

  const [scheme, token] = authHeader.split(' ');
  if (scheme !== 'Bearer') {
    return res.status(400).json({ error: 'Invalid authorization scheme' });
  }

  const { valid, user, error } = validateNexusJWT(token);
  if (!valid) {
    return res.status(401).json({ error: 'Invalid JWT: ' + error });
  }

  req.user = user;
  next();
});
```

---

## Part 3: Ledger Integration (Financial Accounting)

### Service: Ledger
**Purpose**: Financial transaction tracking and 90/10 revenue split
**Base URL**: `https://ledger.graylightcreative.com/api/v1`
**Authentication**: API Key (via Vault)

### Ledger API Key

**Key Name**: `GRAYLIGHT_LEDGER_API_KEY`
**Stored**: GitHub Actions Secrets (Vault)
**Format**: 32 alphanumeric characters

### Endpoints

#### 1. Record Payment Transaction

**Endpoint**: `POST /transactions/record-payment`

**Headers**:
```
Authorization: Bearer <LEDGER_API_KEY>
Content-Type: application/json
X-Service: ngn-2.0
X-Request-ID: <unique-id>
```

**Request** (triggered by Stripe webhook in PHASE_7):
```json
{
  "transaction_id": "txn_1234567890abcdef",
  "source": "stripe",
  "stripe_charge_id": "ch_1234567890abcdef",
  "user_email": "user@example.com",
  "user_id": "user_550e8400e29b41d4a716446655440000",
  "gross_amount": 29.99,
  "currency": "USD",
  "description": "NGN 2.0 License Purchase - Single License",
  "timestamp": "2025-02-11T14:30:00Z",
  "metadata": {
    "license_type": "single",
    "trial_days": 0,
    "product": "ngn-2.0"
  }
}
```

**Response (201)**:
```json
{
  "success": true,
  "transaction_id": "txn_1234567890abcdef",
  "ledger_entries": [
    {
      "entry_id": "LE_20250211_001_90",
      "account": "NGN_REVENUE_90",
      "amount": 26.99,
      "type": "CREDIT",
      "description": "NGN 2.0 License Purchase (90%)",
      "posted_at": "2025-02-11T14:30:05Z"
    },
    {
      "entry_id": "LE_20250211_001_10",
      "account": "SOVEREIGN_INFRASTRUCTURE_FEE_10",
      "amount": 3.00,
      "type": "CREDIT",
      "description": "Sovereign Infrastructure Fee (10%)",
      "posted_at": "2025-02-11T14:30:05Z"
    }
  ],
  "split_percentage": "90/10"
}
```

**Automatic 90/10 Calculation**:
```javascript
// Node.js / Express (PHASE_7)

const SPLIT_RATIO = {
  product_revenue: 0.90,
  infrastructure_fee: 0.10
};

function calculateSplit(grossAmount) {
  const infraFee = Math.round(grossAmount * SPLIT_RATIO.infrastructure_fee * 100) / 100;
  const productRevenue = Math.round((grossAmount - infraFee) * 100) / 100;

  return {
    productRevenue,
    infraFee,
    total: grossAmount
  };
}

// Example:
// calculateSplit(29.99) →
// { productRevenue: 26.99, infraFee: 3.00, total: 29.99 }
```

#### 2. Get Transaction History

**Endpoint**: `GET /transactions?account=NGN_REVENUE_90&start_date=2025-02-01&end_date=2025-02-28`

**Headers**:
```
Authorization: Bearer <LEDGER_API_KEY>
```

**Query Parameters**:
- `account` (string): Account to filter by (NGN_REVENUE_90, SOVEREIGN_INFRASTRUCTURE_FEE_10)
- `start_date` (string, ISO 8601): Start of date range
- `end_date` (string, ISO 8601): End of date range
- `limit` (integer, default 100): Max results

**Response (200)**:
```json
{
  "success": true,
  "account": "NGN_REVENUE_90",
  "period": "2025-02-01 to 2025-02-28",
  "entries": [
    {
      "entry_id": "LE_20250211_001_90",
      "date": "2025-02-11T14:30:05Z",
      "type": "CREDIT",
      "amount": 26.99,
      "description": "NGN 2.0 License Purchase (90%)",
      "source_transaction": "txn_1234567890abcdef"
    },
    {
      "entry_id": "LE_20250212_002_90",
      "date": "2025-02-12T09:15:30Z",
      "type": "CREDIT",
      "amount": 26.99,
      "description": "NGN 2.0 License Purchase (90%)",
      "source_transaction": "txn_1234567890abcef2"
    }
  ],
  "summary": {
    "total_entries": 2,
    "total_credits": 53.98,
    "total_debits": 0.00,
    "balance": 53.98
  }
}
```

#### 3. Get Account Balance

**Endpoint**: `GET /accounts/NGN_REVENUE_90/balance`

**Headers**:
```
Authorization: Bearer <LEDGER_API_KEY>
```

**Response (200)**:
```json
{
  "account": "NGN_REVENUE_90",
  "balance": 53.98,
  "currency": "USD",
  "last_updated": "2025-02-12T09:15:30Z",
  "period": {
    "start": "2025-02-01T00:00:00Z",
    "end": "2025-02-28T23:59:59Z",
    "total_transactions": 2,
    "total_amount": 53.98
  }
}
```

#### 4. Get Infrastructure Fee Summary

**Endpoint**: `GET /accounts/SOVEREIGN_INFRASTRUCTURE_FEE_10/balance`

**Response (200)**:
```json
{
  "account": "SOVEREIGN_INFRASTRUCTURE_FEE_10",
  "balance": 6.00,
  "currency": "USD",
  "last_updated": "2025-02-12T09:15:30Z",
  "period": {
    "start": "2025-02-01T00:00:00Z",
    "end": "2025-02-28T23:59:59Z",
    "total_transactions": 2,
    "total_amount": 6.00
  }
}
```

### Stripe Webhook Handler Implementation (PHASE_7, WEB_004)

```javascript
// routes/webhooks/stripe.js (Express.js)

const express = require('express');
const router = express.Router();
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const axios = require('axios');

// Stripe webhook secret (from Vault via environment)
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

router.post('/stripe', express.raw({type: 'application/json'}), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  let event;

  try {
    // Verify webhook signature
    event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
  } catch (error) {
    console.error('Webhook signature verification failed:', error);
    return res.status(400).send(`Webhook Error: ${error.message}`);
  }

  // Handle payment_intent.succeeded event
  if (event.type === 'payment_intent.succeeded') {
    const paymentIntent = event.data.object;

    try {
      // Record transaction in Ledger
      const ledgerResponse = await axios.post(
        'https://ledger.graylightcreative.com/api/v1/transactions/record-payment',
        {
          transaction_id: paymentIntent.id,
          source: 'stripe',
          stripe_charge_id: paymentIntent.latest_charge,
          user_email: paymentIntent.receipt_email || 'unknown@example.com',
          user_id: paymentIntent.metadata.user_id || null,
          gross_amount: paymentIntent.amount / 100, // Convert from cents
          currency: paymentIntent.currency.toUpperCase(),
          description: `NGN 2.0 License Purchase - ${paymentIntent.metadata.license_type || 'Unknown'}`,
          timestamp: new Date(paymentIntent.created * 1000).toISOString(),
          metadata: paymentIntent.metadata
        },
        {
          headers: {
            'Authorization': `Bearer ${process.env.GRAYLIGHT_LEDGER_API_KEY}`,
            'Content-Type': 'application/json',
            'X-Service': 'ngn-2.0',
            'X-Request-ID': paymentIntent.id
          }
        }
      );

      console.log('Ledger transaction recorded:', ledgerResponse.data);

      // Additional logic: send license to user, create database record, etc.
      // ... (see PHASE_7 task WEB_004)

      res.json({success: true});
    } catch (error) {
      console.error('Ledger API error:', error.response?.data || error.message);
      res.status(500).json({error: 'Ledger recording failed'});
    }
  } else {
    res.json({received: true});
  }
});

module.exports = router;
```

---

## Part 4: Pulse Integration (Telemetry & Analytics)

### Service: Pulse
**Purpose**: Telemetry collection for AI training and analytics
**Base URL**: `https://pulse.graylightcreative.com`
**Endpoint**: `/ingest`
**Authentication**: None (anonymized data only)

### Telemetry Collection (PHASE_5)

#### User Consent (PHASE_4, UX_003)

Before any telemetry is collected, users must opt-in via the Session Setup component:

**UI Component**:
```
┌──────────────────────────────────────────┐
│  ✓ Ready to Mix?                         │
│                                          │
│  Help The Mentor Learn                   │
│  Share usage data to improve the AI      │
│  brain and recommendations for everyone │
│                                          │
│  ☐ Yes, share anonymized data           │
│  ☑ No, keep my data private             │
│  [                  Continue             ]│
└──────────────────────────────────────────┘
```

**Storage** (in plugin preferences):
```
config.telemetry_enabled = false  // Default OFF
```

#### Telemetry Fields

Every 15 minutes of active session (if telemetry enabled):

| Field | Type | Example | Purpose |
|-------|------|---------|---------|
| `cpu_usage_avg` | float | 45.2 | Monitor plugin load on user systems |
| `buffer_size` | integer | 256 | Understand latency requirements |
| `sample_rate` | integer | 48000 | DAW configuration info |
| `daw_name` | string | "Studio One" | Which DAWs are popular |
| `daw_version` | string | "6.5.30" | Which versions have issues |
| `active_instrument_target` | string | "drums" | Which instruments users mix |
| `session_duration_ms` | integer | 1800000 | How long users mix with Mentor |
| `advice_items_clicked` | integer | 7 | Which advice is followed |

#### Anonymization

Before sending to Pulse, data is anonymized:

```cpp
// Source/Telemetry/PulseClient.cpp

#include <openssl/sha.h>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

class PulseClient {
private:
    std::string hardware_id;
    bool telemetry_enabled = false;

    // Hash hardware ID for anonymization
    std::string hashHardwareID(const std::string& id) {
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256((unsigned char*)id.c_str(), id.length(), hash);

        std::ostringstream ss;
        for(int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
            ss << std::hex << (int)hash[i];
        }
        return ss.str();
    }

public:
    void sendTelemetry(const TelemetryData& data) {
        if (!telemetry_enabled) return;

        // Build anonymized telemetry payload
        json payload = {
            {"hardware_id_hash", hashHardwareID(hardware_id)}, // Hashed, not plaintext
            {"cpu_usage_avg", data.cpu_usage},
            {"buffer_size", data.buffer_size},
            {"sample_rate", data.sample_rate},
            {"daw_name", data.daw_name},
            {"daw_version", data.daw_version},
            {"active_instrument_target", data.instrument},
            {"session_duration_ms", data.session_duration},
            {"advice_items_clicked", data.advice_count},
            {"timestamp", getCurrentISOTimestamp()},
            // Note: NO user_id, email, or personal info
        };

        sendToPulseIngest(payload.dump());
    }

private:
    void sendToPulseIngest(const std::string& data) {
        // HTTP POST to Pulse ingest endpoint
        // Minimal network code, no user tracking
        // Retry on failure, but don't block UI
    }
};
```

#### Ingest Endpoint

**Endpoint**: `POST /ingest`

**Headers**:
```
Content-Type: application/json
User-Agent: ngn-2.0-plugin/<version>
```

**Request**:
```json
{
  "batch": [
    {
      "hardware_id_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "cpu_usage_avg": 45.2,
      "buffer_size": 256,
      "sample_rate": 48000,
      "daw_name": "Studio One",
      "daw_version": "6.5.30",
      "active_instrument_target": "drums",
      "session_duration_ms": 1800000,
      "advice_items_clicked": 7,
      "timestamp": "2025-02-11T14:30:00Z"
    },
    {
      "hardware_id_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "cpu_usage_avg": 38.5,
      "buffer_size": 512,
      "sample_rate": 44100,
      "daw_name": "Studio One",
      "daw_version": "6.5.30",
      "active_instrument_target": "vocals",
      "session_duration_ms": 900000,
      "advice_items_clicked": 3,
      "timestamp": "2025-02-11T14:45:00Z"
    }
  ]
}
```

**Response (202 Accepted)**:
```json
{
  "success": true,
  "batch_id": "batch_1707561000001",
  "entries_received": 2,
  "message": "Telemetry batch accepted for processing"
}
```

#### Telemetry Interval

- **Interval**: Every 900,000 ms (15 minutes) of active session time
- **Batch**: Multiple telemetry points batched together (not sent individually)
- **Fallback**: If network fails, data is queued and retried next interval
- **Cleanup**: Telemetry data is cleared from plugin memory after successful send

#### Implementation Checklist (PHASE_5, TEST_004)

- [ ] Consent toggle in Session Setup UI (UX_003)
- [ ] Hardware ID hashing function
- [ ] Telemetry collection during sessions
- [ ] 15-minute batching and queueing
- [ ] Pulse ingest HTTP client
- [ ] Error handling and retry logic
- [ ] Telemetry disabled by default
- [ ] Test with mock Pulse endpoint
- [ ] Verify anonymization (no user IDs in data)

---

## Security Considerations

### All Endpoints

- **HTTPS Only**: All connections use TLS 1.2 or higher
- **No Plaintext**: Never send passwords, keys, or user emails in URLs
- **Rate Limiting**: Implemented per-service (see specific endpoints)
- **Request Signing**: Vault HMAC signatures for critical operations
- **Error Messages**: Never leak sensitive info in error responses

### Authentication

- **JWT**: Expires after 1 hour; refresh token required for extension
- **Forge API Key**: Rotate quarterly; never commit to code
- **HMAC Secret**: Compiled at build; obfuscated in binary

### Data Protection

- **Encryption in Transit**: HTTPS/TLS
- **Encryption at Rest**: Handled by each service (not API's responsibility)
- **Anonymization**: Pulse telemetry anonymized before transmission
- **PII Minimization**: Never collect more than necessary

---

## Error Handling

### Standard Error Format

All errors follow this format:

```json
{
  "error": "error_code",
  "message": "Human-readable error message",
  "timestamp": "2025-02-11T14:30:00Z",
  "request_id": "req_550e8400e29b41d4a716446655440000"
}
```

**Error Codes**:
- `invalid_signature`: HMAC signature does not match
- `expired_timestamp`: Timestamp too old (replay attack prevention)
- `invalid_jwt`: JWT token expired or invalid
- `rate_limited`: Too many requests
- `service_unavailable`: Backend service down
- `invalid_payload`: Request body malformed

### HTTP Status Codes

| Code | Meaning | Retry? |
|------|---------|--------|
| 200 | Success | No |
| 201 | Created | No |
| 202 | Accepted (async) | No |
| 400 | Bad Request | No (fix issue) |
| 401 | Unauthorized | No (fix auth) |
| 403 | Forbidden | No |
| 404 | Not Found | No |
| 409 | Conflict | No |
| 429 | Rate Limited | Yes (with backoff) |
| 500 | Server Error | Yes (with backoff) |
| 502 | Bad Gateway | Yes (with backoff) |
| 503 | Service Unavailable | Yes (with backoff) |

---

## Implementation Roadmap

| Phase | Component | Status |
|-------|-----------|--------|
| PHASE_0 | Project setup, CMake, GitHub Actions | Pending |
| PHASE_2A | Vault HMAC, Online Activation | Pending |
| PHASE_4 | Pulse consent UI (UX_003) | Pending |
| PHASE_5 | Telemetry collection, Pulse ingest | Pending |
| PHASE_7 | Nexus auth, Stripe webhook, Ledger | Pending |
| PHASE_8 | Login/register UI (backend proxy) | Pending |
| PHASE_9 | Database schema (stores JWT, transactions) | Pending |

---

**Document Status**: Complete
**Next Review**: After PHASE_2A implementation
**Maintained By**: Graylight Engineering Team
