#include "HMACKeyManager.h"
#include "HMAC_Keys.h"  // Generated by CMake

#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/crypto.h>
#include <iomanip>
#include <sstream>
#include <cstring>
#include <stdexcept>

namespace Licensing {

HMACKeyManager::HMACKeyManager() {
    deobfuscateKey();
    if (deobfuscated_key_.empty()) {
        throw std::runtime_error("Failed to de-obfuscate HMAC key");
    }
}

HMACKeyManager::~HMACKeyManager() {
    // Securely clear the key from memory
    if (!deobfuscated_key_.empty()) {
        OPENSSL_cleanse(deobfuscated_key_.data(), deobfuscated_key_.size());
    }
}

void HMACKeyManager::deobfuscateKey() {
    deobfuscated_key_.resize(HMAC_SECRET_OBFUSCATED.size());

    // Apply XOR de-obfuscation
    for (size_t i = 0; i < HMAC_SECRET_OBFUSCATED.size(); ++i) {
        deobfuscated_key_[i] = HMAC_SECRET_OBFUSCATED[i] ^ XOR_KEY;
    }
}

std::string HMACKeyManager::computeHMAC(const std::string& message) const {
    if (deobfuscated_key_.empty()) {
        throw std::runtime_error("HMAC key is not initialized");
    }

    unsigned char digest[EVP_MAX_MD_SIZE];
    unsigned int digest_len = 0;

    // Compute HMAC-SHA256
    // EVP_sha256() returns the SHA256 message digest algorithm
    // deobfuscated_key_ is the secret key
    // message.data() and message.length() are the input data
    HMAC(EVP_sha256(),
         deobfuscated_key_.data(),
         deobfuscated_key_.size(),
         reinterpret_cast<unsigned char*>(const_cast<char*>(message.data())),
         message.length(),
         digest,
         &digest_len);

    if (digest_len != 32) {
        throw std::runtime_error("HMAC-SHA256 produced unexpected digest length");
    }

    // Convert binary digest to hex string
    std::ostringstream ss;
    ss << std::hex << std::setfill('0');
    for (unsigned i = 0; i < digest_len; ++i) {
        ss << std::setw(2) << static_cast<int>(digest[i]);
    }

    return ss.str();
}

bool HMACKeyManager::verifyHMAC(const std::string& message, const std::string& signature) const {
    if (deobfuscated_key_.empty()) {
        return false;
    }

    try {
        std::string computed = computeHMAC(message);
        return constantTimeCompare(computed, signature);
    } catch (...) {
        return false;
    }
}

bool HMACKeyManager::constantTimeCompare(const std::string& a, const std::string& b) {
    // Prevent timing attacks by always comparing all bytes,
    // even if lengths differ or early mismatch is found

    if (a.length() != b.length()) {
        return false;  // Different lengths always fail
    }

    int result = 0;
    for (size_t i = 0; i < a.length(); ++i) {
        result |= (a[i] ^ b[i]);
    }

    return result == 0;
}

} // namespace Licensing
